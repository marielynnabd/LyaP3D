""" This module provides a set of functions to get pairs of LOS from a data set, having a certain angular separation """

import numpy as np
import sys, os
import glob
from astropy.table import Table, vstack
import multiprocessing
from multiprocessing import Pool

def get_pairs_single_los(i_los, all_los_table, ang_sep_max, radec_names=['ra', 'dec']):
    """ - This function gets possible pairs for signle los:  
            - Takes a mock generated by mock_generation.py 
            - Returns a table of possible pairs with a max angular separation
    
    Arguments:
    ----------
    i_los: Integer
    Index of LOS with which we want to pair other LOS
    
    all_los_table: Table
    Mock
    
    ang_sep_max: Float, units = degree or Mpc/h
    Maximum angular separation possible between two LOS so that they form a pair
    
    radec_names: List of str, Default: ['ra', 'dec']
    ra dec keys in mocks or data table
    Options: - ['ra', 'dec']: my mocks
             - ['RA', 'DEC']: eBOSS data
             - ['TARGET_RA', 'TARGET_DEC']: IRON
             - ['x', 'y']
    
    Return:
    -------
    los_pairs_table: Table
    Each row corresponds to the indices of the pixels forming the pair, and the angular separation between them
    """

    ra = radec_names[0]
    dec = radec_names[1]
    
    # Initializing los_pairs_table
    single_los_pairs_table = Table()
    
    if radec_names == ['x', 'y']:
        cos_los = 1
    else:
        cos_los = np.cos(all_los_table[dec][i_los] * np.pi / 180)

    los_number = len(all_los_table)
    dalpha = all_los_table[ra][i_los+1:los_number] - all_los_table[ra][i_los]
    ddelta = all_los_table[dec][i_los+1:los_number] - all_los_table[dec][i_los]
    i_neighbors = np.arange(i_los+1, los_number)

    # Selecting a radius of 1 degree around the pixel (First selection)
#     radius_degree = 1
#     if radec_names == ['x', 'y']:
#         radius_Mpc = radius_degree * deg_to_Mpc * h
#         mask1 = (dalpha < radius_Mpc) & (ddelta < radius_Mpc) 
#     else:
#         mask1 = (dalpha < radius_degree) & (ddelta < radius_degree) 

#     ang_sep_local = (dalpha[mask1] * cos_los)**2 + ddelta[mask1]**2
#     ang_sep_local = np.sqrt(ang_sep_local)
    
#     i_neighbors = i_neighbors[mask1]
    ang_sep_local = (dalpha * cos_los)**2 + ddelta**2
    ang_sep_local = np.sqrt(ang_sep_local)

    # Selecting pairs with angular separation < max angular separation we want (Second selection)
    mask2 = (ang_sep_local <= ang_sep_max)
    i_neighbors = i_neighbors[mask2]
    ang_sep_local = ang_sep_local[mask2]
    
    # Filling table
    single_los_pairs_table['index_los1'] = np.ones(len(i_neighbors), dtype='int') * i_los
    single_los_pairs_table['index_los2'] = i_neighbors
    single_los_pairs_table['ang_separation'] = ang_sep_local
    
    return single_los_pairs_table


def compute_pairs(all_los_table, ang_sep_max, radec_names=['ra', 'dec'], ncpu='all', outputfile=None):

    # Getting los_pairs_table from mock 
    if radec_names == ['x', 'y']:
        print('Getting pairs with angular separation < '+str(ang_sep_max)+' Mpc/h')
    else:
        print('Getting pairs with angular separation < '+str(ang_sep_max)+' degrees')

    if ncpu=='all':
        ncpu = multiprocessing.cpu_count()
    print("Number of cpus:", multiprocessing.cpu_count())

    with Pool(ncpu) as pool:
        output_get_pairs_single_los = pool.starmap(
            get_pairs_single_los, [[i, all_los_table, ang_sep_max, radec_names] for i in range(len(all_los_table))])
    output_get_pairs_single_los = [x for x in output_get_pairs_single_los if x is not None] # For sanity check
    all_los_pairs_table = vstack([output_get_pairs_single_los[i] for i in range(len(output_get_pairs_single_los))])

    if outputfile is not None:
        all_los_pairs_table.write(outputfile)
    
    return all_los_pairs_table

